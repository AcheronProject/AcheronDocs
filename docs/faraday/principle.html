

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Principle of operation &mdash; Acheron Project 1.0.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/acheronDocsTheme.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="Introduction" href="intro.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html">
          

          
            
            <img src="../_static/acheronDocsWhite.svg" class="logo" alt="Logo"/>
          
          </a>

          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">The Acheron Project</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../changelog.html">How to read and write The Acheron Docs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../technical.html">Technical Literature</a></li>
</ul>
<p class="caption"><span class="caption-text">Acheron OHL</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../license/license.html">The Acheron Open Hardware License (AOHL) V1.2</a></li>
</ul>
<p class="caption"><span class="caption-text">PCBWay sponsorship</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../pcbway/sponsorship.html">PCBWay sponsorship: how to review PCBs</a></li>
</ul>
<p class="caption"><span class="caption-text">Acheron Library</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../acheronLib/introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../acheronLib/3dmodels.html">The 3D models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../acheronLib/changelog.html">Changelog</a></li>
</ul>
<p class="caption"><span class="caption-text">Anubis</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../anubis/intro.html">Introduction</a></li>
</ul>
<p class="caption"><span class="caption-text">Shark</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../shark/intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../shark/changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../shark/cases.html">The Shark Cases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../shark/ack.html">Acknowledgements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../shark/prototypes.html">Prototypes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../shark/gerbers.html">Manufacturing files</a></li>
</ul>
<p class="caption"><span class="caption-text">Austin</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../austin/intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../austin/changelog.html">Changelog</a></li>
</ul>
<p class="caption"><span class="caption-text">Doddle60</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../doddle60/intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doddle60/files.html">Manufacturing files</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doddle60/changelog.html">Changelog</a></li>
</ul>
<p class="caption"><span class="caption-text">Elevate</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../elevate/introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../elevate/bom.html">Bill of Materials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../elevate/gerbers.html">Manufacturing files</a></li>
<li class="toctree-l1"><a class="reference internal" href="../elevate/changelog.html">Changelog</a></li>
</ul>
<p class="caption"><span class="caption-text">Elongate</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../elongate/introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../elongate/bom.html">Bill of Materials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../elongate/manu.html">Manufacturing files</a></li>
</ul>
<p class="caption"><span class="caption-text">ArcticPCB</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arctic/intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../arctic/changelog.html">Changelog</a></li>
</ul>
<p class="caption"><span class="caption-text">KeebsPCB</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../keebs/intro.html">Introduction</a></li>
</ul>
<p class="caption"><span class="caption-text">Ouroboros</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../ouroboros/intro.html">Ouroboros</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ouroboros/tests.html">Simulations and tests</a></li>
</ul>
<p class="caption"><span class="caption-text">Faraday</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Principle of operation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction">(0) Introduction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#design-philosophy">(0.1) Design philosophy</a></li>
<li class="toctree-l3"><a class="reference internal" href="#basic-principle-of-operation">(0.2) Basic principle of operation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#performance-parameters">(0.3) Performance parameters</a></li>
<li class="toctree-l3"><a class="reference internal" href="#disclosure">(0.4) Disclosure</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#capacitance-sensing-circuit-am-modulator">(1) Capacitance sensing circuit: AM modulator</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#transfer-function-and-basic-mechanism">(1.1) Transfer function and basic mechanism</a></li>
<li class="toctree-l3"><a class="reference internal" href="#determining-filter-parameters">(1.2) Determining filter parameters</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dynamic-response">(1.3) Dynamic response</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#am-signal-de-modulator-circuit">(2) AM signal de-modulator circuit</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#precision-rectifier">(2.1) Precision rectifier</a></li>
<li class="toctree-l3"><a class="reference internal" href="#peak-detector">(2.2) Peak detector</a></li>
<li class="toctree-l3"><a class="reference internal" href="#damped-peak-detector">(2.3) Damped peak detector</a></li>
<li class="toctree-l3"><a class="reference internal" href="#filtered-demodulator">(2.4) Filtered demodulator</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-important-stuff">(2.5) The important stuff</a></li>
<li class="toctree-l3"><a class="reference internal" href="#evaluating-the-c2v-converter-performance">(2.6) Evaluating the C2V converter performance</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#output-signal-linearity">(2.6.1) Output signal linearity</a></li>
<li class="toctree-l4"><a class="reference internal" href="#output-signal-ripple">(2.6.2) Output signal ripple</a></li>
<li class="toctree-l4"><a class="reference internal" href="#output-signal-rise-time">(2.6.3) Output signal rise time</a></li>
<li class="toctree-l4"><a class="reference internal" href="#results-and-discussion">(2.6.4) Results and discussion</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#switch-simulation-circuit">(3) Switch simulation circuit</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#simulating-an-emech-switch-behavior">(3.1) Simulating an emech-switch behavior</a></li>
<li class="toctree-l3"><a class="reference internal" href="#comparator-circuit">(3.3) Comparator circuit</a></li>
<li class="toctree-l3"><a class="reference internal" href="#comparator-circuit-with-hystheresis">(3.4) Comparator circuit with hystheresis</a></li>
<li class="toctree-l3"><a class="reference internal" href="#actuator-circuit">(3.2) Actuator circuit</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#carrier-wave-generator-oscillator">(5) Carrier wave generator oscillator</a></li>
<li class="toctree-l2"><a class="reference internal" href="#power-supply-and-noise-isolation">(6) Power supply and noise isolation</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Acheron Project</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Principle of operation</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/faraday/principle.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="principle-of-operation">
<h1>Principle of operation<a class="headerlink" href="#principle-of-operation" title="Permalink to this headline">¶</a></h1>
<p>This page describes the operation of the Faraday PCB in the details and inner workings. Some sections use heavily on applied mathematics (differential equations, Laplace transforms, transfer functions) and advanced electronics (high frequency signals, oscillators, filter design, high-speed signals processing). The writing is intended for any enthusiast to look at and understandm but nevertheless some time needs to be taken in order to check the ideas involved.</p>
<p>As always, feel free to contact me for questions.</p>
<p>The page is divided into six sections: the introduction; the capacitance AM-modulating circuit; the de-modulation circuit; the circuit used to simulate the behavior of electromechanical switches; the oscillator circuit and the filters used; and the power supply. Apart from the last section, all of the rest are well-founded with equations and SPICE simulations so they are very close to the real-world  behavior of the systems involved. Frequency and time domain plots are presented to validate the reasoning.</p>
<div class="section" id="introduction">
<h2>(0) Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>It has been a problem in the mechanical switch community that there are no custom keyboards that use the famous electro-capacitive Topre switches, which are different from the commonplace electromechanical switches generally used because they offer a very different tactile feeling and sound signature. There were some attempts, but they failed (as long as my researched has concluded). To my evaluation, this has three major factors:</p>
<ul class="simple">
<li><p>Topre switch parts are very difficult to come by. This has been changing in the past days but it is a common belief that, if you want Topre switch parts, you need to buy them from specific vendors;</p></li>
<li><p>There are enough Topre switch OEM keyboards to satisfy the curious users who want a Topre experience: the KKHB Pro 2, the Leopold F660C and the Realforce line of keyboards. The HHKB Pro 2 can even be enhanced by using the famous Hasu controller, giving it bluetooth capabilities and programmability; the main issue being that these keyboards are generally expensive, ranging in the 200-dollar mark;</p></li>
<li><p>The circuitry needed to deal with Topre switches is awfully complicated and difficult to implement; not only that, the available technology is very expensive, making it very hard to compete against the available OEM options. This is the main technical barrier: there are many smart and very intelligent makers in the mechanical keyboards hobby, but to my knowledge a hardware designer and specialist does not figure among them;</p></li>
<li><p>In the attempts that were made to implement custom Topre keyboards, the end product was not QMK compatible. This one is a big no-no for most of the community as QMK is pretty much the backbone of this hobby.</p></li>
</ul>
<p>The Faraday60 is my attempt to solve the third and fourth issues. This PCB is a QMK-compatible, custom PCB for a mechanical keyboard that uses Topre switches. Not only that, it uses simple and cheap circuitry, allowing for implementation in a myriad of layouts.</p>
<p>I hope that, by having an easy-to-use and available custom option for Topre switches, these will spread in the community and parts will become more available.</p>
<div class="section" id="design-philosophy">
<h3>(0.1) Design philosophy<a class="headerlink" href="#design-philosophy" title="Permalink to this headline">¶</a></h3>
<p>The philosophy used for this design is a simple yet difficult one, for simplicity is the ultimate sophistication: designing circuitry for Topre switches that:</p>
<ul class="simple">
<li><p>Is cheap, using cheap and easy-to-find components;</p></li>
<li><p>Can be explained in a simple yet precise way, so that aspiring designers can understand the principles of operations and eventually design their own implementations;</p></li>
</ul>
<p>Also, while in the design process, the main requirements I had were:</p>
<ul class="simple">
<li><p>The tools I used to design, simulate and calculate the circuitry behavior are either free or plainly open-source;</p></li>
<li><p>Documenting every single piece of information and every single thought that I had while designing. This way the design can be improved upon by other designers, creating new implementations for the community;</p></li>
<li><p>Transparency is key. I was always very honest with the flaws in this design. Also, every single flaw has to be justified and understood; if the circuit has an unjustified flaw, I want to know why and how to suppress it;</p></li>
<li><p>Performance requirements are reckless and necessary. While some of the features in this implementation might seem over-engineered, every single step has a justification to be and I always had very clear performance specifications, which I will detail in section <strong>(0.3)</strong></p></li>
</ul>
</div>
<div class="section" id="basic-principle-of-operation">
<h3>(0.2) Basic principle of operation<a class="headerlink" href="#basic-principle-of-operation" title="Permalink to this headline">¶</a></h3>
<p>However complicated, the circuitry has a simple principle of operation.</p>
<p>The Topre switch is basically a travel-to-capacitance transducer. The PCB has a metallic pad with two terminals; once the switch is pressed, a spring between the keycap and the PCB forms a capacitor with the PCB pads in such a way that, the farther the switch is pressed, the higher the capacitive effect sensed between the two terminals of the PCB pads.</p>
<p>In this sense, the PCB circuitry is not concerned with an electromechanical contact like with commonplace mechanical switches, but with the magnitude of the resulting capacitance of the PCB pad. This means that, in essence, Topre PCBs are capacitance sensors that take an action when the capacitance reaches a certain point.</p>
<p>For a common Topre switch, the actuation level is at <span class="math notranslate nohighlight">\(2.2pF\)</span>, that is, the switch is considered pressed when the capacitance between the PCB pad terminals is <span class="math notranslate nohighlight">\(2.2pF\)</span>. When the switch is bottomed-out, that capacitance is <span class="math notranslate nohighlight">\(6pF\)</span>.</p>
<p>The first step is converting the capacitance value into an electrical signal. This is done in the circuitry by using an adaptive filter that outputs a sinusoidal wave. This wave has its amplitude modulated by the sensed capacitance, that is, the amplitude of the sine wave is proportional to the sensed capacitance. This is essentially an AM (Amplitude Modulation) modulator, codifying the signal (capacitance value) into the amplitude of a sinusoidal wave. The technique used for AM modulation is basically an operational-amplifier second-order filter; linear design techniques are employed (basically Laplace transform and Bode Plots).</p>
<p>Next is a circuit that transforms this amplitude into a smooth DC signal. This circuit is known as an AM de-modulator; more specifically, the one used here is a precision de-modulator. This circuit then outputs a DC signal which corresponds to the sensing capacitance. This part of the circuitry is the most delicate one and will be dealt with in a very technical manner, through SPICE simulations. A performance analysis of the system is carried out by means of simulation and statistical analysis.</p>
<p>After the demodulator is a circuit that simulates the activation of an electromechanical switch. This circuit is comprised of a comparator and an opto-coupler, and allows the whole design to be integrated with a switch matrix very similar to the ones generally used by electromechanical keyboards, while galvanically isolating the analog sensing circuitry from the digital keyboard circuitry. This comparator and optocoupler pair is also what enables QMK support.</p>
</div>
<div class="section" id="performance-parameters">
<h3>(0.3) Performance parameters<a class="headerlink" href="#performance-parameters" title="Permalink to this headline">¶</a></h3>
<p>The main difference from my implementation of a Topre PCB to the one that is generally used is that I employ analog precision sensing circuitry to determine the equivalent capacitance of the PCB pads in a given moment. This means that the majority of the circuitry I use is based upon applied electronic design and does not rely on software nor multiplexing techniques.</p>
<p>The advantage of my implementation, as stated, is that it is cheap and easier to understand while also being able to be integrated into a common firmware environment such as QMK.</p>
<p>However, it obviously has downsides, the first of them being the intrinsic issue with all analog sensing circuitry: settling time. All sensors have a period of time to output their readings correctly and that sensing or settling time  must be respected. In this case, the settling time means the time interval between switch activation and the acknowledgement of that activation from the MCU; this time is the main factor contributing to input lag.</p>
<p>In common electromechanical switches, the settling time is virtually zero, owing some time interval only to the parasitic capacitances of the diodes generally employed. In my design, the settling time is significant.</p>
<p>The first performance goal is to achieve a 100 microsecond maximum sensing time; this means that, by design, the time between switch pressing and the MCU acknowledgind that press must be less than that. This value is not arbitrary: most keyboard firmwares (QMK included) use a 1kHz column sensing frequency; the theoretical input lag is rated at least a milisecond, which is the timeframe a column stays at a high state. 100 microseconds is a tenth of that value.</p>
<p>The second performance parameter of the sensing circuit is a 1% voltage precision. This guarantees that the circuit is reliable enough to be used safely as a capacitance-to-voltage transducer. In order to achieve this, all components use must have very tight tolerances – for example, all resistors must be rated 1% or 0.5% and all capacitors 2% or 1%. This ensures that all simulations and calculations presented here are true to reality, that is, the design is close to what really happens.</p>
<p>The third performance parameter is that the system is robust to power supply voltage fluctuations. This is done by using specific operation amplifier topologies and filters.</p>
<p>Finally, the fourth performance parameter is that the analog sensing circuitry must be completely isolated from the digital and power circuitry, avoiding crosstalk and digital noises on analog circuits.</p>
</div>
<div class="section" id="disclosure">
<h3>(0.4) Disclosure<a class="headerlink" href="#disclosure" title="Permalink to this headline">¶</a></h3>
<p>While I am confident that all the design hereby documented is going to work and is very reliable, I cannot guarantee it will work. As of december of 2019, this design has not yet been tested nor prototyped.</p>
</div>
</div>
<div class="section" id="capacitance-sensing-circuit-am-modulator">
<h2>(1) Capacitance sensing circuit: AM modulator<a class="headerlink" href="#capacitance-sensing-circuit-am-modulator" title="Permalink to this headline">¶</a></h2>
<div class="section" id="transfer-function-and-basic-mechanism">
<h3>(1.1) Transfer function and basic mechanism<a class="headerlink" href="#transfer-function-and-basic-mechanism" title="Permalink to this headline">¶</a></h3>
<p>The heart of the whole system is a capacitance sensing circuit, in the form of a simple op-amp filter:</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/current_sensor.svg"><img alt="../_images/current_sensor.svg" src="../_images/current_sensor.svg" width="400px" /></a>
</div>
<p>In this filter, <span class="math notranslate nohighlight">\(C_S\)</span> is the test capacitance which will be measured, while <span class="math notranslate nohighlight">\(C_F\)</span> and <span class="math notranslate nohighlight">\(R_F\)</span> are fixed, project-determined parameters. This filter circuit has transfer function given by</p>
<div class="math notranslate nohighlight">
\[G(s) = \dfrac{V_O(s)}{V_I(s)} = \dfrac{sC_S}{\dfrac{1}{R_F} + sC_F}\]</div>
<p>For the non-initiated in applied mathematics, this transfer function is a complex-valued function (that is, <span class="math notranslate nohighlight">\(s \in \mathbb{C}\)</span>) that describes how the output voltage <span class="math notranslate nohighlight">\(V_O\)</span> changes dynamically according to changes in the input voltage <span class="math notranslate nohighlight">\(V_I\)</span>. For those not familiar with the concept, the Laplace Transform <span class="math notranslate nohighlight">\(\mathcal{L}\left\{f\left(t\right)\right\}\)</span> is a mathematical transformation that associates a time signal <span class="math notranslate nohighlight">\(f\left(t\right)\)</span> to a function in the space of complex frequency <span class="math notranslate nohighlight">\(s \in \mathbb{C}\)</span>, given by</p>
<div class="math notranslate nohighlight">
\[F\left(s\right) := \mathcal{L}\left\{f\left(t\right)\right\}(s) = \int\limits_{-\infty}^{\infty} f\left(t\right)e^{-st}dt,\ F:\mathbb{C}\to\mathbb{C}\]</div>
<p>For Linear-Time-Invariant systems (linear systems that do not change with time, that is, dont “get older”), it can be shown that the time representation and the frequency-domain representation are interchangeable, a property we will use soon.</p>
<p>One of the many useful tricks allowed by this transformation is to analyse the response of an LTI system given a pure sine wave. Substituting <span class="math notranslate nohighlight">\(s = j\omega\)</span> (<span class="math notranslate nohighlight">\(j\)</span> being the imaginary unity that satisfyes <span class="math notranslate nohighlight">\(j^2 = -1\)</span>) one can deduce the behavior of the system to pure-frequency sinusoidal signals. This means that, if the input signal is a pure-sine wave of frequency <span class="math notranslate nohighlight">\(\omega\)</span>, the transfer function has an amplitude which is proportional to <span class="math notranslate nohighlight">\(C_S\)</span>:</p>
<div class="math notranslate nohighlight">
\[\left\lvert G(j\omega) \right\rvert = \dfrac{\omega C_S}{\sqrt{\dfrac{1}{R_F^2} + \omega^2C_F^2}}\]</div>
<p>The main idea is then that, if <span class="math notranslate nohighlight">\(V_I(t)\)</span> is a perfect sinusoidal wave with frequency <span class="math notranslate nohighlight">\(\omega_0\)</span>, the output <span class="math notranslate nohighlight">\(V_O(t)\)</span> will be a sinusoidal wave with frequency <span class="math notranslate nohighlight">\(\omega_0\)</span> but which amplitude is proportional to <span class="math notranslate nohighlight">\(C_S\)</span>:</p>
<div class="math notranslate nohighlight">
\[\dfrac{\left\lvert V_O(j\omega) \right\rvert}{\left\lvert V_I(j\omega)\right\rvert} = \dfrac{\omega C_S}{\sqrt{\dfrac{1}{R_F^2} + \omega^2C_F^2}} \Rightarrow C_S = \sqrt{\dfrac{1}{\omega^2R_F^2} + C_F^2}\dfrac{\left\lvert V_O(j\omega) \right\rvert}{\left\lvert V_I(j\omega)\right\rvert}\]</div>
<p>Hence, since <span class="math notranslate nohighlight">\(\omega\)</span>, <span class="math notranslate nohighlight">\(R_F\)</span> and <span class="math notranslate nohighlight">\(C_F\)</span> are known, by measuring the output and input amplitudes one can obtain <span class="math notranslate nohighlight">\(C_S\)</span>.</p>
<p>It is interesting and important to note that since the amplitude of the output sinusoidal wave will be proportional to the value of <span class="math notranslate nohighlight">\(C_S\)</span>, then this circuit is actually an Amplitude Modulator which generates an Amplitude Modulated (AM) signal; as such, it is natural to think that after this circuit an AM de-modulator will be needed to complete the capacitance-to-voltage sensor; the frequency at which the carrier wave oscillates will be henceforth called <span class="math notranslate nohighlight">\(\omega_0\)</span>.</p>
</div>
<div class="section" id="determining-filter-parameters">
<h3>(1.2) Determining filter parameters<a class="headerlink" href="#determining-filter-parameters" title="Permalink to this headline">¶</a></h3>
<p>Before doing any simulations, the parameters <span class="math notranslate nohighlight">\(R_F\)</span> and <span class="math notranslate nohighlight">\(C_F\)</span> must be determined. Topre switches cause a capacitance variation from 0 farads (or at least a very low quantity due to stray capacitances) to 6pF when bottomed out; the switch actuates at around 2.2pF. Then, let us adopt as a design parameter that at 6pF the transfer function must have a unitary gain at the carrier frequency <span class="math notranslate nohighlight">\(\omega_0\)</span>, that is:</p>
<div class="math notranslate nohighlight">
\[\left\lvert G(j\omega_0) \right\rvert = 1 = \dfrac{\omega_0 C_S}{\sqrt{\dfrac{1}{R_F^2} + \omega_0^2C_F^2}}\]</div>
<p>This design requirement is not arbitrary. The main issue associated with analog precision sensing circuitry are the second-order effects that op-amps introduce in the system, the most famous of which is the output saturation due to voltage rails. An operational amplifier will not output a voltage higher than <span class="math notranslate nohighlight">\(V_{CC}\)</span> nor lower than <span class="math notranslate nohighlight">\(V_{SS}\)</span>. In practicality, the limits of the output are even tighter; as a rule of thumb, we assume that the op-amp will clamp outputs higher than <span class="math notranslate nohighlight">\(V_{CC}-2\)</span> and lower than <span class="math notranslate nohighlight">\(V_{SS}+2\)</span>. While there are op-amps that have output limits very tight to the power rails (called rail-to-rail op-amps), these are generally more expensive and difficult to use than your everyday TL081s. For instance, the figure below shows the maximum output voltage of a TL08x operation amplifier as a function of operating frequency. Note that the maximum acievable output voltages are significantly lower than the power voltages supplied. (Image taken from the <a class="reference external" href="http://www.ti.com/lit/ds/symlink/tl082.pdf">TL08x datasheet</a>).</p>
<div class="figure align-center" id="id1">
<span id="tl082-datasheet-graph"></span><a class="reference internal image-reference" href="../_images/tl082_voltage.svg"><img alt="../_images/tl082_voltage.svg" src="../_images/tl082_voltage.svg" width="400px" /></a>
<p class="caption"><span class="caption-number">Figure 24 </span><span class="caption-text">. Datasheet plot showing the maximum output voltage for the TL081 opamp as a function of frequency.</span><a class="headerlink" href="#id1" title="Permalink to this image">¶</a></p>
</div>
<p>The datasheet also denotes</p>
<div class="figure align-center" id="id2">
<span id="tl082-datasheet-table"></span><a class="reference internal image-reference" href="../_images/tl082_datasheet_table.svg"><img alt="../_images/tl082_datasheet_table.svg" src="../_images/tl082_datasheet_table.svg" width="800px" /></a>
<p class="caption"><span class="caption-number">Figure 25 </span><span class="caption-text">. Datasheet table showing the typical maximum output voltage for the TL081 opamp (image edited for clarity).</span><a class="headerlink" href="#id2" title="Permalink to this image">¶</a></p>
</div>
<p>A value of <span class="math notranslate nohighlight">\(V_{CC} = -V_{SS} = 15V\)</span> will be used; these voltages are easily generated from the USB power input through precision integrated buck-boost converters as the <a class="reference external" href="https://lcsc.com/product-detail/DC-DC-Converters_TI-Tex-as-Instruments_TPS61040DBVR_TI-Tex-as-Instruments-TI-TPS61040DBVR_C7722.html">TPS61040</a> . The input voltage amplitude will be <span class="math notranslate nohighlight">\(6.8V\)</span> (this value is also not arbitrary and its reason will be seen in the next section), which gives plenty headroom for the op-amps to work with without going into voltage saturation.</p>
<p>There is also the problem of choosing <span class="math notranslate nohighlight">\(\omega_0\)</span>. This frequency should be in the kHz range, as PCB layout starts to get more and more complicated as MHz-range signals are used due to impedance effects. Also generating such high frequencies is no easy matter for your common solid state oscillators. The frequency of 100kHz was chosen, since it is both easy to generate and this value is very friendly to work with in PCB layouts.</p>
<p>There is also the problem of keyboard input lag. In the first designs, I used the 10kHz frequency, which is very easily generated and can be easily incorporated into PCB designs. The problem with this freqency at the end is that the AM demodulator project got too complicated, as this is a too low of a frequency to carry an AM signal and the AM demodulator dynamics got too slow; hence, the decay and charge times of the demodulator would range in the miliseconds range, which is noticeable. It also needs to be noted that the column and row sweep times of common keyboard firmwares (such as QMK) is generally 1kHz; because of this, having a milisecond-time dynamic for the demodulator will add input lag to the keyboard.</p>
<p>In the second design, at 100kHz, it is very easy to design an AM demodulator with dynamics fast as to not add significant input lag. Also 100kHz is an easy to generate frequency and also easy to deal with, as most commonplace operational amplifiers can deal with that frequency range.</p>
<p>In this case, one can obtain a relation between <span class="math notranslate nohighlight">\(R_F\)</span> and <span class="math notranslate nohighlight">\(C_F\)</span>:</p>
<div class="math notranslate nohighlight">
\[1 = \dfrac{2\pi\times 100\times 10^3\times C_S}{\sqrt{\dfrac{1}{R_F^2} + \left(2\pi\times 100\times 10^3\right)^2C_F^2}}\]</div>
<p>From here the values must be matched from the feasible resistance and capacitance values and the values the component supplier can provide. Since this is a sensor circuit, the components used must have the lowest tolerances possible. 1% or even 0.5% resistors can be easily found, while low tolerance capacitors are harder to find. In this sense, it is better to first find a capacitor value that is available in a low tolerance and then find a matching resistor. For example, Murata Electronics’ GRM0333C1H2R7WA01D is a <span class="math notranslate nohighlight">\(2.7pF\)</span> resistor with <span class="math notranslate nohighlight">\(\pm 0.05pF\)</span> tolerance, that is, <span class="math notranslate nohighlight">\(\pm 1.85\%\)</span> tolerance, which is very good. Using <span class="math notranslate nohighlight">\(C_F = 2.7pF\)</span> yields <span class="math notranslate nohighlight">\(R_F = 297k\Omega\)</span>. One can easily use <a class="reference external" href="https://lcsc.com/product-detail/Chip-Resistor-Surface-Mount_UNI-ROYAL-Uniroyal-Elec-0603WAD3004T5E_C423050.html">Uniroyal Electric’s 0603WAD3004T5E</a>, which is a 300 kilo-Ohm resistor with 0.5% tolerance. Recalculating the gain at 100kHz yields</p>
<div class="math notranslate nohighlight">
\[\left\lvert G(j2\pi\times 100 \times 10^3) \right\rvert = \dfrac{2\pi\times 100\times 10^3 6\times 10^{-12}}{\sqrt{\dfrac{1}{\left(3\times 10^{6}\right)^2} + (2\pi\times 100\times 10^3)^2\left(2.7\times 10^{-12}\right)^2}} = 1.007944041\]</div>
<p>Which is very close to the intended unitary gain, validating the designed circuit.</p>
</div>
<div class="section" id="dynamic-response">
<h3>(1.3) Dynamic response<a class="headerlink" href="#dynamic-response" title="Permalink to this headline">¶</a></h3>
<p>There is, however, a small problem with the calculations above: they are based on a steady-state analysis of how the amplitude of the output wave changes with respect to the capacitance value. In the realtime, dynamic behaviors exist: upon a change in the measured capacitance, even if that change is instant, the change in the amplitude of the output voltage is not. There is a transient that the amplitude faces before going to its intended value; if that transient is too slow, that means that the circuit takes too much time to register the capacitance change (that is, the circuit take too much time to register a keypress), rendering the keyboard unusable. Because of this, a thorough dynamical simulation of the key actuation and how the circuit behaves is salutar.</p>
<p>Let’s use the circuit transfer function to simulate the output response of the circuit. Suppose that the input voltage is a sinusoidal wave with amplitude <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(\omega_0\)</span> frequency; then its Laplace Transform is given by</p>
<div class="math notranslate nohighlight">
\[V_I(t) = A\cos\left(\omega_0 t\right) \Rightarrow V_I(s) = \dfrac{As}{s^2 + \omega_0^2}\]</div>
<p>Let us also admit that the capacitance <span class="math notranslate nohighlight">\(C_S\)</span> changes instantly from 0 to a value <span class="math notranslate nohighlight">\(C\)</span> at instant zero, which is actually the instant at which the switch is pressed; hence, <span class="math notranslate nohighlight">\(C_S\)</span> is modelled as a step of amplitude <span class="math notranslate nohighlight">\(C\)</span>:</p>
<div class="math notranslate nohighlight">
\[C_S(t) = C\delta(t) \Rightarrow C_S(s) = \dfrac{C}{s}\]</div>
<p>In this situation, the output voltage transfer function is</p>
<div class="math notranslate nohighlight">
\[V_O(s) = \dfrac{CAs}{\left(s^2 + \omega_0^2\right)\left(\dfrac{1}{R_F} + sC_F\right)} = \dfrac{sCA}{s^3C_F + s^2\dfrac{1}{R_F} + sC_F\omega_0^2 + \dfrac{\omega_0}{R_F}}\]</div>
<p>Expanding this expression in partial fractions,</p>
<div class="math notranslate nohighlight">
\[V_O(s) = \dfrac{ACR_F}{C_F^2R_F^2\omega_0^2 + 1}\left(\dfrac{C_FR_F\omega_0^2 + s}{s^2 + \omega_0^2} - \dfrac{1}{s + \dfrac{1}{C_FR_F}} \right)\]</div>
<p>Taking the inverse Laplace transform yields</p>
<div class="math notranslate nohighlight">
\[V_O(t) = \dfrac{ACR_F}{C_F^2R_F^2\omega_0^2 + 1}\left[\left(\sqrt{C_F^2R_F^2\omega_0^4 + 1}\right)\cos\left(\omega_0 t + \theta\right) - e^{-\dfrac{t}{C_FR_F}}\right], tan\left(\theta\right) = \dfrac{1}{C_FR_F\omega_0^2}\]</div>
<p>Naturally, the first term – the cosine –  is the steady-state response of <span class="math notranslate nohighlight">\(V_O\)</span> while the exponential term accounts for the transient behavior aforementioned. It is interesting to note that such transient will be as fast as the time constant <span class="math notranslate nohighlight">\(\tau_{trans} = R_FC_F\)</span>, meaning that the lower this constant, the faster the transient is.</p>
<p>As was determined in the last section, we will use <span class="math notranslate nohighlight">\(C = 6pF\)</span>, <span class="math notranslate nohighlight">\(A = 6.8V\)</span>, <span class="math notranslate nohighlight">\(\omega_0 = 10kHz\)</span>, <span class="math notranslate nohighlight">\(R_F = 300k\Omega\)</span>, <span class="math notranslate nohighlight">\(C_F = 2.7pF\)</span>, yielding <span class="math notranslate nohighlight">\(\tau_{trans} = 810ns\)</span>; in general the time for the exponential term to fade is considered to be three to fice times this constant, which would be at most 4 microsseconds. This means that the transient response seen is very fast and can be safely and ultimately neglected – as for all intents and purposes the transient behavior can be considered null adter five to ten times the time constant, that is, between four and eight microsseconds.</p>
<p>Hence the final capacitance-to-AM modulator circuit adopted is given below.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/current_sensor_real.svg"><img alt="../_images/current_sensor_real.svg" src="../_images/current_sensor_real.svg" width="400px" /></a>
</div>
<p>The plot below shows the step response of this system, as simulated in LTSpice (a dedicated integrated electronics simulation software). This simulation uses a transistor-level model for the operational amplifier, meaning it is very true to reality.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/capSenseResponse.svg"><img alt="../_images/capSenseResponse.svg" src="../_images/capSenseResponse.svg" width="600px" /></a>
</div>
<p>As expected, the amplitude dynamic response is very fast, ranging in the 4 microsseconds we predicted, validating the design.</p>
</div>
</div>
<div class="section" id="am-signal-de-modulator-circuit">
<h2>(2) AM signal de-modulator circuit<a class="headerlink" href="#am-signal-de-modulator-circuit" title="Permalink to this headline">¶</a></h2>
<p>The AM-modulator circuit works in a very simple purpose: it codifies the measured capacitance into the amplitude of a sinusoidal wave. However useful, this information cannot be translated into a working circuit. The goal now is to design a circuit that measures the amplitude of a sine wave and outputs the amplitude of that wave in a DC voltage signal. Such circuit is called an AM-demodulator. Such circuit is shown in the figure below.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/full_demodulator.svg"><img alt="../_images/full_demodulator.svg" src="../_images/full_demodulator.svg" width="600px" /></a>
</div>
<p>Note that the input voltage of this circuit is the output voltage of the AM modulator of the last section, meaning it is a sinusoidal wave which amplitude codifies the value of the measured capacitance.</p>
<p>This circuit has a very intricate funcioning, which will be explained in detail below.</p>
<div class="section" id="precision-rectifier">
<h3>(2.1) Precision rectifier<a class="headerlink" href="#precision-rectifier" title="Permalink to this headline">¶</a></h3>
<p>First, consider the circuit immediately below, called a precision full-wave rectifier. Such circuit takes advantage of the high open-loop gain of operational amplifiers to remove the effects of the forward voltages of the diodes, rectifying the input sine wave to almost perfection.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/precision_rectifier.svg"><img alt="../_images/precision_rectifier.svg" src="../_images/precision_rectifier.svg" width="600px" /></a>
</div>
<p>The rectifier does its job, transforming the sinusoidal wave into a pulsating DC voltage.</p>
</div>
<div class="section" id="peak-detector">
<h3>(2.2) Peak detector<a class="headerlink" href="#peak-detector" title="Permalink to this headline">¶</a></h3>
<p>When <span class="math notranslate nohighlight">\(C_1\)</span> is added to the rectifier, the circuit becomes what is called a peak detector, which outputs the highest registered level of the input voltage. This would be enough for us, because as the switch is pressed and the input sine wave rises, the peak detector would output the amplitude of that wine wave, which is exactly what we want. There is, however, a small problem with that: if the sine wave decreases its amplitude, the output voltage does not change accordingly. See the below figure for details.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/peak_detector.svg"><img alt="../_images/peak_detector.svg" src="../_images/peak_detector.svg" width="600px" /></a>
</div>
<p>In the figure, note how when the amplitude of the input voltage decreases, the output voltage does not decrese. In practicality, this means that if we active the switch, the demodulator will detect the activation, but when we release the switch, the demodulator will act as if the switch was held. To remedy this, a resistor is added in parallel to the capacitor.a</p>
</div>
<div class="section" id="damped-peak-detector">
<h3>(2.3) Damped peak detector<a class="headerlink" href="#damped-peak-detector" title="Permalink to this headline">¶</a></h3>
<p>Adding a discharge resistor to the capacitor allows it do discharge when the input voltage amplitude goes down. This circuit is known as a damped peak detector.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/damped_peak_detector.svg"><img alt="../_images/damped_peak_detector.svg" src="../_images/damped_peak_detector.svg" width="700px" /></a>
</div>
<p>This is not the final circut, however. The issue with the damped peak detector is that, in order for the release detection to work fast enough, the RC filter is fast enough to discharge between the sinusoidal peaks, generating a distortion called ripple. So we want the lowest ripple possible. However, if we use too high of a resistance, the time the circuit takes to respond to a change in the voltage input amplitude becomes too high, meaning that the circuit will take too long to detec the switch activation or deactivation. The faster we want the circuit to react, the higher the ripple, making it a design tradeoff. In general, it is recommended that one chooses <span class="math notranslate nohighlight">\(R_1\)</span> and <span class="math notranslate nohighlight">\(C_1\)</span> such that the time constant <span class="math notranslate nohighlight">\(R_1C_1\)</span> is ten times greater than the carrier wave period.</p>
</div>
<div class="section" id="filtered-demodulator">
<h3>(2.4) Filtered demodulator<a class="headerlink" href="#filtered-demodulator" title="Permalink to this headline">¶</a></h3>
<p>In order to filter the ripple, a low-pass filter is added to the circuit output, originating the final full demodulator circuit.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/demodulator.svg"><img alt="../_images/demodulator.svg" src="../_images/demodulator.svg" width="800px" /></a>
</div>
<p>This circuit gives a smooth DC voltage in it output which corresponds to the amplitude of the input sine wave, which is what we wanted after all. It is important to note, however, that the addition of this lowpass filter will not totally remove ripple, but reduce it to very low levels. Not only that, it is important to have in mind that the addition of this circuit to the <span class="math notranslate nohighlight">\(C_1R_5\)</span> circuit will add loading effect to the circuit, meaning that the design of both filters must be done at the same time, that is, you cannot design one after the other independently as they affect each other’s behavior.</p>
<p>However it has another issue: due to the ripple filtering, the output voltage is not exactly the peak of the input voltage, but a diminished value – see the arrow indications in the above picture. The output voltage is naturally higher the higher is the input voltage amplitude. Not only this, but the voltage drop is non-linear; the actual math is available (see for example Shade Graphs for rectifier design) but is way too complicated and unnecessary.</p>
</div>
<div class="section" id="the-important-stuff">
<h3>(2.5) The important stuff<a class="headerlink" href="#the-important-stuff" title="Permalink to this headline">¶</a></h3>
<p>Having given the step-by-step construction of the demodulator, one may find its project to be unecessarily difficult. The main issue is building a circuit which components can be easily found and cheaply bought. There are many ready-to-use modulators and demodulators, but these are generally expensive and difficult to find.</p>
<p>At the end of the day, however, all we need to know about our circuit are two things:</p>
<ul class="simple">
<li><ol class="arabic simple">
<li><p>Is the demodulator fast enough to detect switch activation and deactivation without significant dynamic response time? And</p></li>
</ol>
</li>
<li><ol class="arabic simple" start="2">
<li><p>What is the output of the demodulator at the exact capacitance of the switch activation?</p></li>
</ol>
</li>
</ul>
<p>The end result is almost entirely based off of electronic dynamic simulation, and the RC filters are designed in a very iteractive, back-and-forth basis due to the inherent nonlinearity of the process. I have determined the values for resistances and capacitances through LTSpice simulation; the resulting circuit is shown in <a class="reference internal" href="#figure-demodulator-real"><span class="std std-numref">Figure 26</span></a>.</p>
<div class="figure align-center" id="id3">
<span id="figure-demodulator-real"></span><a class="reference internal image-reference" href="../_images/demodulator_real.svg"><img alt="../_images/demodulator_real.svg" src="../_images/demodulator_real.svg" width="800px" /></a>
<p class="caption"><span class="caption-number">Figure 26 </span><span class="caption-text">. Schematic of the AM modulator and demodulator circuits with component ratings and opamp models.</span><a class="headerlink" href="#id3" title="Permalink to this image">¶</a></p>
</div>
<p>The next plot shows the step time response of this circuit. In this plot, the sensed capacitor goes instantly (step function) to 6 picofarads at 20 microseconds.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/demodulator_6p.svg"><img alt="../_images/demodulator_6p.svg" src="../_images/demodulator_6p.svg" width="1000px" /></a>
</div>
<p>The plot shows the important waveforms as well as a zoom-out on the waves in their steady-state form. It is important to see how the damped peak detector outputs a very rippled waveform and how the output filter is effective on making it a smooth DC signal. It is also important to note that the output signal is so smooth to the point that we can consider it basically a DC signal. The plot below shows the time responde of the system top various amplitudes of capacitance step.</p>
</div>
<div class="section" id="evaluating-the-c2v-converter-performance">
<h3>(2.6) Evaluating the C2V converter performance<a class="headerlink" href="#evaluating-the-c2v-converter-performance" title="Permalink to this headline">¶</a></h3>
<p>So let us resume what we have so far.</p>
<p>First, a sinusoidal 100kHz signal is generated. This signal is then used with a capacitance sensor so that the output is a 100kHz sine wave which amplitude is proportional do the capacitance being sensed. This circuit is known as an Amplitude Modulation (AM) modulator.</p>
<p>Then, a de-modulator is used to convert the amplitude value of the generated sine wave to a smooth DC voltage. The modulator and de-modulator circuit form then what is called a Capacitance-to-Voltage converter (C2V). The image below shows a step time response of the whole modulator and demodulator circuit when the capacitor being sensed suffers a variety of amplitudes.</p>
<p>In this subsection I will dissert about the techniques and parameters I used to evaluate the C2V sensor performance.</p>
<p>The three parameters I used were:</p>
<ul class="simple">
<li><p><strong>Output signal linearity</strong>. Ideally, a sensor will output a signal that is proportional to the quantity being sensed. Linearity is an amazing property that will greatly ease the measurement and signal processing. Since the output signal is not perfectly linear, we want to measure “how linear” the output signal is. This is done by measuring the average value of the output wave in its permanent behavior. In practical terms, this linearity means that the C2V output is well-behaved with respect to the switch travel distance, that is, the output signal is not too big or too low and doesn’t change its behavior abruptly during the switch travel time.</p></li>
<li><p><strong>Output signal distortion</strong>. Also ideally, a C2V sensor will output a perfectly smooth DC voltage. We saw in the last graph that this is not true: the output wave is rippled, albeit by a little. Hence it is necessary to measure the ripple and compare it to the actual wave value. In practical terms, this ripple basically means the accuracy of the sensor, that is, the smoother the output wave is, the more accurate the measurement is.</p></li>
<li><p><strong>Sensor rise time</strong>. In the field of Control Theory, the rise time is defined as the amount of time that the system needs to attain 95% of the final output value. In practical terms, the rise time is a measurement of how fast the system reacts to the input signal. In practical terms, we want the system to have at most a 100 microsecond rise time, because that was one of the main performance requirements of the sensor, listed in the introduction.</p></li>
</ul>
<p>The plot below shows the time response of the sensor to steps in the input (capacitance), which simulate a very fast switch press. The many capacitance values mean various level of keypress, to exemplify how the system behaves to various levels of input.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/switch_values.svg"><img alt="../_images/switch_values.svg" src="../_images/switch_values.svg" width="1000px" /></a>
</div>
<p>The evaluation of these performance parameters applied to this circuit will be done in the following manner. This circuit was simulated six thousand times with six thousand different input capacitance values, from time zero to a milisecond (fairly enough to hit the static behavior). The output wave was cut for the last 20 microseconds and three parameters were measured: rise time of the curve since time zero; average and peak-to-peak values of the wave in the last 20 microseconds.</p>
<p>The parameter analysis will use a stochastic and discrete Minimum Least Squares method, which is basically a statistic time-fitting analysis of the discrete time response of the system.</p>
<div class="section" id="output-signal-linearity">
<h4>(2.6.1) Output signal linearity<a class="headerlink" href="#output-signal-linearity" title="Permalink to this headline">¶</a></h4>
<p>The plot below shows the average value of the C2V converter output voltage as a function of input capacitance.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/C2V_linearity.svg"><img alt="../_images/C2V_linearity.svg" src="../_images/C2V_linearity.svg" width="600px" /></a>
</div>
<p>As it can be seen, the curve is extremely linear. A stochastic Minimum Squares fit will confirm these results:</p>
<div class="math notranslate nohighlight">
\[\overline{V} = \left(1.255 \pm 0.001366\right)C + \left(-0.1062 \pm 0.004738\right)\]</div>
<p>Where <span class="math notranslate nohighlight">\(\overline{V}\)</span> is the average output voltage in volts and ..math:<cite>C</cite> is the input capacitance in picofarads. The coefficient uncertainties are measured considering a 95% confidence interval. The measured R-squared coefficient is 0.99993, confirming that this is a very good approximation.</p>
</div>
<div class="section" id="output-signal-ripple">
<h4>(2.6.2) Output signal ripple<a class="headerlink" href="#output-signal-ripple" title="Permalink to this headline">¶</a></h4>
<p>It is also interesting to note that the ripple is very linear with capacitance (despite small spikes). The plot below shows the measured peak-to-peak voltaeg of the output C2V voltage as a function of input capacitance.</p>
<div class="figure align-center" id="id4">
<span id="c2v-peaktopeak"></span><a class="reference internal image-reference" href="../_images/C2V_peaktopeak.svg"><img alt="../_images/C2V_peaktopeak.svg" src="../_images/C2V_peaktopeak.svg" width="600px" /></a>
<p class="caption"><span class="caption-number">Figure 27 </span><span class="caption-text">. Output voltage ripple amplitude as function of sensed capacitance.</span><a class="headerlink" href="#id4" title="Permalink to this image">¶</a></p>
</div>
<div class="math notranslate nohighlight">
\[V_{pp} = \left(2.103  \pm 0.02874\right)C + \left(-0.015.76\times \pm 0.0009967 \right)\]</div>
<p>Where <span class="math notranslate nohighlight">\(\overline{V}\)</span> is the average output voltage in milivolts and ..math:<cite>C</cite> is the input capacitance in picofarads. The coefficient uncertainties are measured considering a 95% confidence interval. The measured R-squared coefficient is 0.99989, confirming again that this is a very good approximation.</p>
<p>It is then interesting to note that, since both ripple and average value are very linear to the capacitance, the average-to-ripple ratio is very good and can be calculated by using the Chain Rule and the Propagation of Uncertainty formula:</p>
<div class="math notranslate nohighlight">
\[\dfrac{\partial \overline{V}}{\partial V_{pp}} = \dfrac{\dfrac{\partial \overline{V}}{\partial C}}{\dfrac{\partial V_{pp}}{\partial C}} = 5.76.766524013 \pm 8.181351195\]</div>
<p>This means that, given a change in capacitance, we can assert that the output ripple will rise six hundred times slower than the average value, which is an amazing result for a capacitive sensor. More precisely, we can theoretically state with 95% confidence that this relation will be in the <span class="math notranslate nohighlight">\(\left[588.585172818, 604.947875208\right]\)</span> interval.</p>
</div>
<div class="section" id="output-signal-rise-time">
<h4>(2.6.3) Output signal rise time<a class="headerlink" href="#output-signal-rise-time" title="Permalink to this headline">¶</a></h4>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/C2V_risetime.svg"><img alt="../_images/C2V_risetime.svg" src="../_images/C2V_risetime.svg" width="660px" /></a>
</div>
<p>The risetime falls into the sub-100 microsecond category, maxing out at almost 70, which is very satisfactory.</p>
</div>
<div class="section" id="results-and-discussion">
<h4>(2.6.4) Results and discussion<a class="headerlink" href="#results-and-discussion" title="Permalink to this headline">¶</a></h4>
<p>The results show that the designed circuit passes the performance requirements with flying colors, attendind every requisite with much room to spare.</p>
<p>It is very important to note that the nonlinear, stochastic and simulatory analysis hereby presented is developed upon ideal conditions – perfect components and no parasitic second-order effects. The main issue here is the tolerances of the components, which can greatly alter the time and frequency response of the system. The operational amplifiers guarantee that these tolerances will not have a significant effect to some extent, but nevertheless it is of the utmost importance to use precise components with at most 2% tolerance.</p>
<p>Also, there is a very difficult issue with implementation of this circuit which is PCB layout. Since all waves have a fundamental frequency of the modulator carrier (100kHz), a badly laid out PCB can generate parasitic capacitances and inductances that can simply destroy the circuit behavior and make all the analysis here useless, specially because of the fairly analog and high speeds involved. Hence, all these results require a very well laid-out PCB and circuit stability, which can be expected from USB-based PCBs.</p>
<p>The AM modulator and AM de-modulator circuit will henceforth be called a C2V (Capacitance-to-Voltage) converter.</p>
</div>
</div>
</div>
<div class="section" id="switch-simulation-circuit">
<h2>(3) Switch simulation circuit<a class="headerlink" href="#switch-simulation-circuit" title="Permalink to this headline">¶</a></h2>
<p>The C2V converter is a circuit that outputs a DC voltage correspnding to a sensed capacitance (the switch). Ultimately what we want is to simulate an emech switch activation on the MCU switch matrix, connecting a particular row to a particular column. This simulation, however, must be triggered only if the input capacitance hits a cretain level that corresponds to the Topre switch activation point, 2.2pF to be more exact. In our circuit, this means that this simulation must only be triggered when the C2V output voltage hits 2.389V.</p>
<p>The simulation circuit is then comprised of two stages:</p>
<ul class="simple">
<li><p><strong>(1) A comparator (or voltage detector)</strong>. The comparator stage detects a voltage level greater than 2.389V coming from the C2V, and triggers the actuator when that happens. The comparator used here also features a noise-filtering capability called <em>hystheresis</em>, which protects the circuit from the voltage ripples produced by the C2V.</p></li>
<li><p><strong>(2) An actuator (or decoupler)</strong>.  The actuator actuates on the MCU switch matrix when it is triggered, but there is a catch: it  must also meet performance requirements, the first requirement being that the actuator must offer n-key rollover and anti-ghosting capabilities to the matrix. The second requirement being that this actuator must isolate the sensing circuitry from the digital MCU part, in order to make the sensing circuit more reliable. Finally, this circuit must be again cheap, easy to understand and easily available.</p></li>
</ul>
<div class="section" id="simulating-an-emech-switch-behavior">
<h3>(3.1) Simulating an emech-switch behavior<a class="headerlink" href="#simulating-an-emech-switch-behavior" title="Permalink to this headline">¶</a></h3>
<p>In order to understand how the actuator circuit simulates an electromechanical switch and diode pair, let us first understand how a keyboard switch matrix works. During normal operation, a Microprocessor Unit (MCU) has its pins connected to rows and columns; the rows and columns are connected by switches. Electrically, switches are nothing more than simple electromechanical short-circuits activated when the switch is pressed. This short-circuit is generally comprised by two leaf contacts that are pressed against each other.</p>
<p>All the rows are set as input (most commonly open-drain) and all columns are set as outputs (most commonly push-pulls). At a given moment only one column can be at high state; in that moment, the MCU senses for voltage in the row pins. If a given row pin receives a high state, that is because the switch corresponding to that particular column and row was pressed.</p>
<p>After some time (generally a milisecond) that particular row is turned off and the next row receives a high state; the MCU then scans for actions on the rows.i This cycle runs endlessly until the MCU is turned off, and constitutes the main loop of a keyboard firmware.</p>
<p>The problem with switches, however, is that since they are short circuits, current can flow in both directions. Say that at a particular time the column 1 is at high state, and the switch at column 1 and row 2 is pressed. If another switch is also pressed in the same column, say, switch at row 2 column 3, then columns 1 and 3, as well as row 2, are short-circuited. This may cause many effects from damaging the MCU to causing very high currents; the most known phenomena and common is <strong>ghosting</strong>, where this situation makes the MCU register <em>ghost</em> keys that were not pressed.</p>
<p>To remedy this, diodes are generally used in series with the switches; these diode, presenting assymetrical conduction, will prevent currents from flowing back to the switches and causing unintended issues. This way we can press any combination of switches in the keyboard and the MCU will register the right keypresses; this feature is known as <em>n-key rollover</em> or nKRO. Also this technique enables the MCU to not detech ghost keypresses, that is, this implementation prevents ghosting, a feature called <em>anti-ghosting</em> or AGh.</p>
<p>Komar, the designer of the famous GH60 PCB, has an amazing explanation in <a class="reference external" href="http://blog.komar.be/how-to-make-a-keyboard-the-matrix/">his blog</a>, definitely worth the reading for any PCB designer worth their salt.</p>
</div>
<div class="section" id="comparator-circuit">
<h3>(3.3) Comparator circuit<a class="headerlink" href="#comparator-circuit" title="Permalink to this headline">¶</a></h3>
<p>We know from our C2V simulations that  when it outputs a voltage grater than 2.389 volts, we can consider that the switch is activated. Fortunately, there is a very handy circuit in electronics called a comparator, shown in the figure below, that can be used as a voltage level detection circuit.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/comparator_circuit.svg"><img alt="../_images/comparator_circuit.svg" src="../_images/comparator_circuit.svg" width="300px" /></a>
</div>
<p>The comparator works in a very simple manner: if <span class="math notranslate nohighlight">\(V_P &gt; V_N\)</span>, the output is ideally <span class="math notranslate nohighlight">\(V_{CC}\)</span> (remember that this only happens with a special kind of opamp called rail-to-rail; a common opamp will input only approximately <span class="math notranslate nohighlight">\(V_{CC}-2\)</span>); if <span class="math notranslate nohighlight">\(V_P &lt; V_N\)</span> then the output voltage is VSS (then again, normal opamps will output approximately <span class="math notranslate nohighlight">\(V_{SS}+2\)</span>).</p>
<p>A very common technique is to generate a reference signal through a voltage resistor divider from VCC, as denoted in <a class="reference internal" href="#comparator-circuit-ideal"><span class="std std-numref">Figure 28</span></a>. The figure also shows the output response of the system: <span class="math notranslate nohighlight">\(V_o = V_H\)</span> if <span class="math notranslate nohighlight">\(V_I &gt; V_F\)</span> and <span class="math notranslate nohighlight">\(V_o = V_L\)</span> if <span class="math notranslate nohighlight">\(V_I &lt; V_F\)</span>. <span class="math notranslate nohighlight">\(V_H\)</span> and <span class="math notranslate nohighlight">\(V_L\)</span> are the maximum and minimum peak voltages of the opmp at <span class="math notranslate nohighlight">\(V_{CC}\)</span>; as <a class="reference internal" href="#tl082-datasheet-table"><span class="std std-numref">Figure 25</span></a> shows, for the TL08x at 15V, those are <span class="math notranslate nohighlight">\(\pm 13.5V\)</span>. It is interesting to note that since the opamp has a very high input impedance, one can calculate <span class="math notranslate nohighlight">\(V_F\)</span> as</p>
<div class="math notranslate nohighlight">
\[V_F = V_{CC}\dfrac{R_1}{R_1 + R_2}\]</div>
<div class="figure align-center" id="id5">
<span id="comparator-circuit-ideal"></span><a class="reference internal image-reference" href="../_images/comparator_circuit_ideal.svg"><img alt="../_images/comparator_circuit_ideal.svg" src="../_images/comparator_circuit_ideal.svg" width="800px" /></a>
<p class="caption"><span class="caption-number">Figure 28 </span><span class="caption-text">. Ideal voltage-divider-fed comparator circuit</span><a class="headerlink" href="#id5" title="Permalink to this image">¶</a></p>
</div>
<p>This is the key: if we assume <span class="math notranslate nohighlight">\(V_N = 2.289V\)</span> and hook up the AM de-modulator circuit to <span class="math notranslate nohighlight">\(V_P\)</span> then we will achieve the very result we want: the output signal will be approximately VCC-2 when the PCB pads sensed capacitance is greater than 2.2pF (key is activated) and VSS+2 when it is not pressed. Producing a 2.389V level is easy, it can be done by using a resistive divider with 11.1k and 2.10k resistors, which will input a 2.389V into <span class="math notranslate nohighlight">\(V_N\)</span>, which is very close to the 2.43V we seek. See the circuit below for the real implementation. Capacitor <span class="math notranslate nohighlight">\(C_1\)</span> is used to prevent spikes on the 15V supply to interfere with the sensing action.</p>
<div class="figure align-center" id="id6">
<span id="comparator-circuit-real"></span><a class="reference internal image-reference" href="../_images/comparator_circuit_real.svg"><img alt="../_images/comparator_circuit_real.svg" src="../_images/comparator_circuit_real.svg" width="400px" /></a>
<p class="caption"><span class="caption-number">Figure 29 </span><span class="caption-text">. Voltage-divider-fed comparator circuit using TL081, designed to trigger at the 2.389V (2.2pF) voltage mark.</span><a class="headerlink" href="#id6" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="comparator-circuit-with-hystheresis">
<h3>(3.4) Comparator circuit with hystheresis<a class="headerlink" href="#comparator-circuit-with-hystheresis" title="Permalink to this headline">¶</a></h3>
<p>The circuit in figure <a class="reference internal" href="#comparator-circuit-real"><span class="std std-numref">Figure 29</span></a> has a problem, however: it reacts very wildly to flickering or rippled voltages. <a class="reference internal" href="#comparator-nonhystheresis-response"><span class="std std-numref">Figure 30</span></a> shows the time response of that circuit given a flickering input voltage.</p>
<div class="figure align-center" id="id7">
<span id="comparator-nonhystheresis-response"></span><a class="reference internal image-reference" href="../_images/comparator_nonhystheresis_response.svg"><img alt="../_images/comparator_nonhystheresis_response.svg" src="../_images/comparator_nonhystheresis_response.svg" width="400px" /></a>
<p class="caption"><span class="caption-number">Figure 30 </span><span class="caption-text">. Time response (top plot) of the circuit of <a class="reference internal" href="#comparator-circuit-real"><span class="std std-numref">Figure 29</span></a> given a flickering input voltage (bottom plot).</span><a class="headerlink" href="#id7" title="Permalink to this image">¶</a></p>
</div>
<p>In keyboard practical terms, this means that the comparator will trigger the switch simulation circuit uninterruptly, which will make the MCU register the same key countless times inside a very small time space, an unwanted behavior we generally call “key chattering”. A very effective way to solve this issue is to add a feedback resistor, which generates a feature called <strong>hystheresis</strong>. <a class="reference internal" href="#comparator-circuit-hystheresis-ideal"><span class="std std-numref">Figure 31</span></a> shows the circuit schematic and its input-output response.</p>
<div class="figure align-center" id="id8">
<span id="comparator-circuit-hystheresis-ideal"></span><a class="reference internal image-reference" href="../_images/comparator_circuit_hystheresis_ideal.svg"><img alt="../_images/comparator_circuit_hystheresis_ideal.svg" src="../_images/comparator_circuit_hystheresis_ideal.svg" width="800px" /></a>
<p class="caption"><span class="caption-number">Figure 31 </span><span class="caption-text">. Voltage-divider-feedback-ed comparator ideal circuit.</span><a class="headerlink" href="#id8" title="Permalink to this image">¶</a></p>
</div>
<p>What is interesting about this circuit is that it adds a sort of “conditional response”. Applying the Kirchoff Current Law yields</p>
<div class="math notranslate nohighlight">
\[\dfrac{V_0 - V_F}{R_F} + \dfrac{V_F}{R_2} = \dfrac{V_{CC} - V_F}{R_1} \Leftrightarrow V_F = \dfrac{\dfrac{V_{CC}}{R_1} - \dfrac{V}{R_F}}{\dfrac{1}{R_1} + \dfrac{1}{R_2} - \dfrac{1}{R_F}}\]</div>
<p>Suppose that the circuit is working with a very low input voltage and it keeps growing. The output voltage is <span class="math notranslate nohighlight">\(V_L\)</span>, so the feedback voltage is given by</p>
<div class="math notranslate nohighlight">
\[V_{FH} = \dfrac{\dfrac{V_{CC}}{R_1} - \dfrac{V_L}{R_F}}{\dfrac{1}{R_1} + \dfrac{1}{R_2} - \dfrac{1}{R_F}}\]</div>
<p>Meaning that the output voltage will only rise when the input voltage is <span class="math notranslate nohighlight">\(V_{FH}\)</span>. Similarly, if the input voltage is too high and keeps getting lower, the feedback voltage is given by</p>
<div class="math notranslate nohighlight">
\[V_{FL} = \dfrac{\dfrac{V_{CC}}{R_1} + \dfrac{V_H}{R_F}}{\dfrac{1}{R_1} + \dfrac{1}{R_2} - \dfrac{1}{R_F}}\]</div>
<p>And then the output voltage will only lower when the input voltage is <span class="math notranslate nohighlight">\(V_{FL}\)</span>.</p>
<p>The magical thing about this circuit is that it has a small amplitude <span class="math notranslate nohighlight">\(V_A\)</span>, around a central voltage <span class="math notranslate nohighlight">\(V_C\)</span>, in the input thresholds that prevent it from reacting to flickering signals:</p>
<div class="math notranslate nohighlight">
\[A = V_{FH} - V_{FL} = \dfrac{ \dfrac{V_H - V_L}{R_F}}{\dfrac{1}{R_1} + \dfrac{1}{R_2} - \dfrac{1}{R_F}}\]</div>
<div class="math notranslate nohighlight">
\[V_C = \dfrac{\dfrac{V_{CC}}{R_1} - \dfrac{V_L + V_H}{2R_F}}{\dfrac{1}{R_1} + \dfrac{1}{R_2} - \dfrac{1}{R_F}}\]</div>
<p><a class="reference internal" href="#comparator-circuit-hystheresis-ideal-response"><span class="std std-numref">Figure 32</span></a> shows the input-output-response of the comparator with hystheresis consiering the central voltage and voltage amplitude.</p>
<div class="figure align-center" id="id9">
<span id="comparator-circuit-hystheresis-ideal-response"></span><a class="reference internal image-reference" href="../_images/comparator_circuit_hystheresis_ideal_response.svg"><img alt="../_images/comparator_circuit_hystheresis_ideal_response.svg" src="../_images/comparator_circuit_hystheresis_ideal_response.svg" width="600px" /></a>
<p class="caption"><span class="caption-number">Figure 32 </span><span class="caption-text">. Voltage-divider-feedback-ed comparator ideal circuit input-output-response.</span><a class="headerlink" href="#id9" title="Permalink to this image">¶</a></p>
</div>
<p>The formulas, however, are pretty difficult, specially because they contain three resistance parameters to tune. What is generally done is to consider <span class="math notranslate nohighlight">\(R_F\)</span> much greater than <span class="math notranslate nohighlight">\(R_1\)</span> or <span class="math notranslate nohighlight">\(R_2\)</span>, which is generally true. Under this assumption, we can approximate</p>
<div class="math notranslate nohighlight">
\[A \approx \dfrac{1}{R_F}\dfrac{ V_H - V_L}{\dfrac{1}{R_1} + \dfrac{1}{R_2}}\]</div>
<div class="math notranslate nohighlight">
\[V_C \approx \dfrac{\dfrac{V_{CC}}{R_1}}{\dfrac{1}{R_1} + \dfrac{1}{R_2}}\]</div>
<p>What we want ultimately is that the amplitude voltage be bigger than the ripple amplitude, avoiding that the circuit respond too rapidly due to the ripple. As a security, measure, we generally adopt the amplitude as twice the maximum ripple. From <a class="reference internal" href="#c2v-peaktopeak"><span class="std std-numref">Figure 27</span></a> we can assume that, at the desired actuation point (2.2pF), the ripple is almost 4mV; hence we want a hystheresis amplitude of 8mV. Using the same resistances from the non-hysteresis comparator yields</p>
<div class="math notranslate nohighlight">
\[R_F \approx \dfrac{1}{8\times 10^{-3}}\dfrac{ 13.5 - \left(-13.5\right) }{\dfrac{1}{11.1\times 10^3} + \dfrac{1}{2.01\times 10^3}} = 5.743678489702517M\Omega\]</div>
<p>Adopting the nearest value, <span class="math notranslate nohighlight">\(5.76M\Omega\)</span>. If you feel uncomfortable with the approximations, you can use the non-approximated formulas:</p>
<div class="math notranslate nohighlight">
\[A = \dfrac{ \dfrac{13.5 - \left(-13.5\right)}{5.76\times 10^6}}{\dfrac{1}{11.1\times 10^3} + \dfrac{1}{2.01\times 10^3} - \dfrac{1}{5.76\times 10^6}} = 8.207749 mV\]</div>
<div class="math notranslate nohighlight">
\[V_C = \dfrac{\dfrac{15}{11.1\times 10^3} - \dfrac{13.5-\left(-13.5\right)}{2\times 5.76\times 10^6}}{\dfrac{1}{11.1\times 10^3} + \dfrac{1}{2.01\times 10^3} - \dfrac{1}{5.76\times 10^6}} = 2.294971102V\]</div>
<p>Which are values close to the ones wanted: <span class="math notranslate nohighlight">\(8mV\)</span> and <span class="math notranslate nohighlight">\(2.389V\)</span>, but not quite there. We can adjust <span class="math notranslate nohighlight">\(R_1\)</span> and <span class="math notranslate nohighlight">\(R_2\)</span> slightly to <span class="math notranslate nohighlight">\(R_1 = 10.7k\Omega\)</span> and <span class="math notranslate nohighlight">\(R_2 = 2k\Omega\)</span>, and keeping <span class="math notranslate nohighlight">\(R_F = 5.76M\Omega\)</span>,</p>
<div class="math notranslate nohighlight">
\[A = \dfrac{ \dfrac{13.5 - \left(-13.5\right)}{5.76\times 10^6}}{\dfrac{1}{10.7\times 10^3} + \dfrac{1}{2\times 10^3} - \dfrac{1}{5.76\times 10^6}} = 7.900933mV\]</div>
<div class="math notranslate nohighlight">
\[V_C = \dfrac{\dfrac{15}{10.7\times 10^3} - \dfrac{13.5 - \left(-13.5\right)}{2\times 5.76\times 10^6}}{\dfrac{1}{10.7\times 10^3} + \dfrac{1}{2\times 10^3} - \dfrac{1}{5.76\times 10^6}} = 2.407013612V\]</div>
<p><a class="reference internal" href="#comparator-hystheresis-response"><span class="std std-numref">Figure 33</span></a> shows the output of this circuit to a flickering input signal. Comparing this response to <a class="reference internal" href="#comparator-nonhystheresis-response"><span class="std std-numref">Figure 30</span></a> makes clear how the hystheresis makes the circuit much more well-behaved, making it much more well-suited to a rippled voltage like the one that the C2V outputs.</p>
<div class="figure align-center" id="id10">
<span id="comparator-hystheresis-response"></span><a class="reference internal image-reference" href="../_images/comparator_hystheresis_response.svg"><img alt="../_images/comparator_hystheresis_response.svg" src="../_images/comparator_hystheresis_response.svg" width="400px" /></a>
<p class="caption"><span class="caption-number">Figure 33 </span><span class="caption-text">. Time response (top plot) of the circuit of <a class="reference internal" href="#comparator-circuit-real"><span class="std std-numref">Figure 29</span></a> given a flickering input voltage (bottom plot).</span><a class="headerlink" href="#id10" title="Permalink to this image">¶</a></p>
</div>
<p>And those are much closer results.</p>
<p><a class="reference external" href="http://www.ti.com/lit/ug/tidu020a/tidu020a.pdf">http://www.ti.com/lit/ug/tidu020a/tidu020a.pdf</a></p>
</div>
<div class="section" id="actuator-circuit">
<h3>(3.2) Actuator circuit<a class="headerlink" href="#actuator-circuit" title="Permalink to this headline">¶</a></h3>
<p>For now, what I want to emphasize is: the circuit used for simulating the switch and diode behavior has to provide the same features – namely, nKRO and AGh. What is interesting to note is that a switch plus diode pair is basically an electrical contact that only conducts current in one way.</p>
<p>If you know electronics at an enough high level, a lighbulb might have popped in your head: a current conductor that conducts current in a single way when an electrical signal is input is simply a saturated bipolar transistor; a simple common collector or common drain topology will serve as an electronically controlled switch that conducts current in a single way. And that is perfectly correct. However, those topologies have a major flaw: not only they need a power supply, they also need biasing components. These two requirements will make the circuit significantly bigger and complex. Also, it is known that the behavior of these topologies is extremely dependant on the tolerances of those components and the parameter variation of the transistor, which is huge for commonplace BC548s.</p>
<p>A far easier solution to this task is using an <strong>opto-coupler</strong>. This device is made of an LED (generally infra-red emitter) and a transistor with an open gate (a phototransistor); when the LED conducts light directly into the transistor’s base, the base is overflown with carriers due to photon recombination at the energy band level, making the transistor conduct current too. This topology uses only a single component, does not need a dedicated power supply, and will provide the assymetrical conductance we need for the AGh and nKRO.</p>
<p>Another advantage of this device is that it galvanically isolates the diode matrix and the capacitor sensing circuit. Whereas the switch matrix uses the USB or LDO-provided 5 or 3.3V for its operation, the capacitance sensing uses 15V generated by a voltage source. Not only that, mixing the digital power rails and analog sensing power rails can be disastrous to the sensing circuit, because it relies on very precise measurements to work. Hence, not only the opto-coupler does the job of being an actuator, it also promotes isolation between digital processing circuit and analog sensor, greatly enhancing the reliability of the circuit.</p>
</div>
</div>
<div class="section" id="carrier-wave-generator-oscillator">
<h2>(5) Carrier wave generator oscillator<a class="headerlink" href="#carrier-wave-generator-oscillator" title="Permalink to this headline">¶</a></h2>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/oscillator_dft.svg"><img alt="../_images/oscillator_dft.svg" src="../_images/oscillator_dft.svg" width="60px" /></a>
</div>
</div>
<div class="section" id="power-supply-and-noise-isolation">
<h2>(6) Power supply and noise isolation<a class="headerlink" href="#power-supply-and-noise-isolation" title="Permalink to this headline">¶</a></h2>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="intro.html" class="btn btn-neutral float-left" title="Introduction" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Alvaro &#34;Gondolindrim&#34; Volpato

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>